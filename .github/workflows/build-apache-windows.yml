name: Build Apache on Windows with RDP Debug Pause

on:
#   push:
#     branches: [ main ] # Trigger on push to main branch
  workflow_dispatch: # Allow manual trigger

jobs:
  build:
    runs-on: windows-latest # Use the latest Windows runner

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4 # Checks out your repository code

    - name: Install Prerequisites
      run: |
        choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' -y
        choco install strawberryperl -y
        choco install nasm -y
        choco install 7zip.install -y
      shell: powershell

    - name: Add 7zip to PATH # Ensure 7z is available in subsequent steps
      run: |
        echo "C:\Program Files\7-Zip" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
      shell: powershell

    # --- MODIFIED: Added output for rdp_url ---
    - name: Setup RDP
      id: setup-rdp
      shell: pwsh
      env:
        NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
        RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
      run: |
        $ngrokLogFile = "$env:GITHUB_WORKSPACE\ngrok.log"
        $ngrokProcess = $null
        $rdpUser = "runneradmin"
        $rdpUrlOutput = "" # Variable to hold the URL for output

        if ([string]::IsNullOrEmpty($env:NGROK_AUTH_TOKEN)) { Write-Error "NGROK_AUTH_TOKEN secret is not set."; exit 1 }
        if ([string]::IsNullOrEmpty($env:RDP_PASSWORD)) { Write-Error "RDP_PASSWORD secret is not set."; exit 1 }

        Write-Host "Setting RDP user '$rdpUser'..."
        try {
          $securePassword = ConvertTo-SecureString -String $env:RDP_PASSWORD -AsPlainText -Force
          try { Get-LocalUser -Name $rdpUser | Set-LocalUser -Password $securePassword -ErrorAction Stop; Write-Host "Password set via Set-LocalUser."}
          catch { Write-Warning "Set-LocalUser failed: $($_.Exception.Message). Trying 'net user'..."; iex "net user $rdpUser '$($env:RDP_PASSWORD)'"; if ($LASTEXITCODE -ne 0) { throw "net user failed too."}; Write-Host "Password set via 'net user'." }
        } catch { Write-Error "Failed to configure RDP user '$rdpUser': $_"; if (Get-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue) { Remove-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue }; exit 1 }

        Write-Host "Ensuring RDP is enabled..."
        try {
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -Value 0 -Force -ErrorAction Stop
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop" -ErrorAction Stop
          Write-Host "RDP enabled and firewall rule checked."
        } catch { Write-Warning "Failed to explicitly enable RDP or firewall rule: $_. Assuming it's already configured." }

        Write-Host "Setting up ngrok..."
        try { choco install ngrok -y --force --no-progress --ignore-checksums }
        catch {
          Write-Warning "Chocolatey install failed or choco not found. Attempting manual download..."
          $ngrokZip = "$env:TEMP\ngrok.zip"; $ngrokExe = "$env:TEMP\ngrok.exe"
          Invoke-WebRequest "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile $ngrokZip -ErrorAction Stop
          Expand-Archive $ngrokZip -DestinationPath $env:TEMP -Force -ErrorAction Stop
          Move-Item "$env:TEMP\ngrok.exe" $ngrokExe -Force -ErrorAction Stop
          Remove-Item $ngrokZip -Force -ErrorAction Stop
          $env:PATH += ";$env:TEMP"
        }
        if (-not (Get-Command ngrok -ErrorAction SilentlyContinue)) { Write-Error "ngrok command not found after installation attempts."; Remove-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue; exit 1 }
        Write-Host "Configuring ngrok authtoken..."
        ngrok config add-authtoken $env:NGROK_AUTH_TOKEN --log=stdout

        Write-Host "Starting ngrok RDP tunnel (TCP port 3389)..."
        $ngrokArgs = "tcp 3389 --log `"$ngrokLogFile`""
        try {
          $ngrokProcess = Start-Process ngrok -ArgumentList $ngrokArgs -WindowStyle Hidden -PassThru -ErrorAction Stop
          Write-Host "ngrok process started (PID: $($ngrokProcess.Id)). Waiting for tunnel info..."
          Start-Sleep -Seconds 15
          $rdpUrl = $null; $maxAttempts = 5; $attempt = 0
          while ($attempt -lt $maxAttempts -and -not $rdpUrl) {
              $attempt++; if (Test-Path $ngrokLogFile) { $logContent = Get-Content $ngrokLogFile -Raw -ErrorAction SilentlyContinue; $match = $logContent | Select-String -Pattern 'url=(tcp://[^ ]+)'; if ($match) { $rdpUrl = $match.Matches[0].Groups[1].Value; Write-Host "RDP Connection URL found: $rdpUrl"; $rdpUrlOutput = $rdpUrl; break } }
              Write-Host "Waiting for ngrok URL in log... (Attempt $attempt/$maxAttempts)"; Start-Sleep -Seconds 5
          }
          if (-not $rdpUrl) { throw "Failed to retrieve RDP connection URL from ngrok log ($ngrokLogFile) after $maxAttempts attempts." }
          Write-Host "----------------------------------------------------------------------"
          Write-Host "RDP is ready for connection if needed."
          Write-Host "Connect using an RDP client to: $rdpUrl"
          Write-Host "Username: $rdpUser"
          Write-Host "Password: Use the value from your RDP_PASSWORD secret."
          Write-Host "----------------------------------------------------------------------"
          # --- Set the output variable ---
          echo "::set-output name=rdp_url::$rdpUrlOutput"
        } catch {
          Write-Error "Failed during ngrok setup or tunnel retrieval: $_"
          if ($ngrokProcess) { Stop-Process -Id $ngrokProcess.Id -Force -ErrorAction SilentlyContinue }
          if (Get-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue) { Remove-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue }
          exit 1
        }

    - name: Create Source Directory
      run: mkdir src
      shell: cmd

    # --- MODIFIED: Added try/catch and pause logic ---
    - name: Download and Extract Dependencies
      shell: powershell
      run: |
        # Helper function for pausing
        function Pause-For-RdpDebug($errorMessage) {
            Write-Error "ERROR ENCOUNTERED: $errorMessage"
            Write-Host "----------------------------------------------------------------------"
            Write-Host "WORKFLOW PAUSED FOR DEBUGGING (Max ~6 hours)"
            Write-Host "Connect via RDP to investigate."
            Write-Host "RDP URL: ${{ steps.setup-rdp.outputs.rdp_url }}" # Use output from previous step
            Write-Host "Username: runneradmin"
            Write-Host "Password: Use your RDP_PASSWORD secret."
            Write-Host "The runner will remain active for debugging. Manually cancel the job when done."
            Write-Host "----------------------------------------------------------------------"
            Start-Sleep -Seconds 21600 # Pause for 6 hours
            # After sleep/timeout, exit with error to mark step as failed
            exit 1
        }

        # Helper function for downloading and extracting
        function Get-AndExtract($url, $archiveName, $extractDir) {
          $downloadPath = Join-Path $env:RUNNER_TEMP $archiveName
          try {
              Write-Host "Downloading $url to $downloadPath"
              Invoke-WebRequest -Uri $url -OutFile $downloadPath -ErrorAction Stop
              Write-Host "Extracting $downloadPath to $extractDir"
              # Use 7z with ErrorAction Stop
              if ($archiveName -like '*.tar.gz' -or $archiveName -like '*.tar.xz') {
                  # 7z can fail, so check exit code
                  & 7z x $downloadPath -so | & 7z x -aoa -si -ttar -o"$extractDir"
                  if ($LASTEXITCODE -ne 0) { throw "7z extraction failed for $archiveName (tar stage)" }
              } elseif ($archiveName -like '*.zip') {
                  & 7z x $downloadPath -aoa -o"$extractDir"
                  if ($LASTEXITCODE -ne 0) { throw "7z extraction failed for $archiveName (zip stage)" }
              } else {
                  throw "Unsupported archive type for $archiveName"
              }
              # Remove the archive after extraction
              Remove-Item $downloadPath -Force -ErrorAction Stop
          } catch {
              # Call the pause function on error within Get-AndExtract
              Pause-For-RdpDebug "Failed during download/extract of '$archiveName': $($_.Exception.Message)"
          }
        }

        $baseSrcPath = Join-Path $env:GITHUB_WORKSPACE "src"

        $packages = @{
          "zlib-1.3.1"          = "https://zlib.net/zlib-1.3.1.tar.gz"
          "pcre2-10.45"         = "https://github.com/PCRE2Project/pcre2/releases/download/pcre2-10.45/pcre2-10.45.tar.gz"
          "expat-2.7.1"         = "https://github.com/libexpat/libexpat/releases/download/R_2_7_1/expat-2.7.1.tar.gz"
          "openssl-3.3.3"       = "https://www.openssl.org/source/openssl-3.3.3.tar.gz"
          "libxml2-2.14.1"      = "https://download.gnome.org/sources/libxml2/2.14/libxml2-2.14.1.tar.xz"
          "jansson-2.14.1"      = "https://github.com/akheron/jansson/releases/download/v2.14.1/jansson-2.14.1.tar.gz"
          "brotli-1.1.0"        = "https://github.com/google/brotli/archive/refs/tags/v1.1.0.tar.gz"
          "lua-5.4.7"           = "https://www.lua.org/ftp/lua-5.4.7.tar.gz"
          "apr-1.7.5"           = "https://dlcdn.apache.org/apr/apr-1.7.5.tar.gz"
          "apr-iconv-1.2.2"     = "https://dlcdn.apache.org/apr/apr-iconv-1.2.2.tar.gz"
          "apr-util-1.6.3"      = "https://dlcdn.apache.org/apr/apr-util-1.6.3.tar.gz"
          "nghttp2-1.65.0"      = "https://github.com/nghttp2/nghttp2/releases/download/v1.65.0/nghttp2-1.65.0.tar.gz"
          "curl-8.13.0"         = "https://curl.se/download/curl-8.13.0.tar.gz"
          "httpd-2.4.63"        = "https://dlcdn.apache.org/httpd/httpd-2.4.63.tar.gz"
          "mod_fcgid-2.3.9"     = "https://dlcdn.apache.org/httpd/mod_fcgid/mod_fcgid-2.3.9.tar.gz"
        }

        # Wrap the main loop in try/catch
        try {
            foreach ($pkgName in $packages.Keys) {
                $url = $packages[$pkgName]
                $archiveName = $url.Split('/')[-1]
                $finalExtractPath = Join-Path $baseSrcPath $pkgName
                $tempExtractDir = Join-Path $baseSrcPath "$($pkgName)-temp-extract"

                if (Test-Path $finalExtractPath) { Remove-Item $finalExtractPath -Recurse -Force -ErrorAction SilentlyContinue } # Continue if removal fails slightly
                if (Test-Path $tempExtractDir) { Remove-Item $tempExtractDir -Recurse -Force -ErrorAction SilentlyContinue }

                # Call the extraction function (it has its own try/catch now)
                Get-AndExtract -url $url -archiveName $archiveName -extractDir $tempExtractDir

                # --- Logic to handle nested folders (wrap this in try/catch too) ---
                try {
                    $extractedItems = Get-ChildItem -Path $tempExtractDir -Force -ErrorAction Stop
                    if ($extractedItems.Count -eq 1 -and $extractedItems[0].PSIsContainer) {
                        $extractedFolder = $extractedItems[0]
                        Write-Host "Single folder '$($extractedFolder.Name)' found. Moving/Renaming to $finalExtractPath"
                        Move-Item -Path $extractedFolder.FullName -Destination $finalExtractPath -Force -ErrorAction Stop
                    } elseif ($extractedItems.Count -gt 0) {
                        Write-Host "Multiple items found. Moving contents to $finalExtractPath"
                        if (-not (Test-Path $finalExtractPath)) { mkdir $finalExtractPath -ErrorAction Stop }
                        Move-Item -Path (Join-Path $tempExtractDir "*") -Destination $finalExtractPath -Force -ErrorAction Stop
                    } else {
                        throw "No items found in $tempExtractDir after extraction for $pkgName."
                    }
                    if (Test-Path $tempExtractDir) { Remove-Item $tempExtractDir -Recurse -Force -ErrorAction Stop }
                } catch {
                    Pause-For-RdpDebug "Failed during post-extraction file handling for '$pkgName': $($_.Exception.Message)"
                }
                # --- End folder handling logic ---

                # Final verification
                if (-not (Test-Path $finalExtractPath) -or (Get-ChildItem -Path $finalExtractPath -Force -ErrorAction Stop).Count -eq 0) {
                    Pause-For-RdpDebug "Final directory $finalExtractPath verification failed for $pkgName."
                } else {
                    Write-Host "Successfully prepared $pkgName in $finalExtractPath"
                }
            } # End foreach package
            Write-Host "All dependencies downloaded and extracted successfully."
        } catch {
             # Catch errors not caught by inner try/catch blocks (less likely now)
             Pause-For-RdpDebug "An unexpected error occurred in the main dependency loop: $($_.Exception.Message)"
        }

    - name: Set up MSBuild and VS Environment
      uses: microsoft/setup-msbuild@v2

    - name: Set VCVARSALL environment variable
      id: set_vcvars
      shell: powershell
      run: |
        $vcvarsPath = ""
        # Try common paths, add more specific paths if needed based on runner images
        $potentialPaths = @(
            (Join-Path $env:VCINSTALLDIR "Auxiliary\Build\vcvars64.bat" -ErrorAction SilentlyContinue),
            "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat",
            "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat",
            "C:\Program Files (x86)\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat",
            "C:\Program Files (x86)\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
        )

        foreach ($path in $potentialPaths) {
            if ($path -and (Test-Path $path -PathType Leaf)) {
                $vcvarsPath = $path
                Write-Host "Found vcvars64.bat at: $vcvarsPath"
                break
            }
        }

        if ($vcvarsPath) {
            Write-Host "Setting VCVARSALL environment variable."
            echo "VCVARSALL=$vcvarsPath" >> $env:GITHUB_ENV
        } else {
            # Use the Pause function if vcvars not found
            # Define it again or make it globally available if needed in multiple steps
            function Pause-For-RdpDebug($errorMessage) {
                 Write-Error "ERROR ENCOUNTERED: $errorMessage"
                 Write-Host "----------------------------------------------------------------------"
                 Write-Host "WORKFLOW PAUSED FOR DEBUGGING (Max ~6 hours)"
                 Write-Host "Connect via RDP to investigate."
                 Write-Host "RDP URL: ${{ steps.setup-rdp.outputs.rdp_url }}"
                 Write-Host "Username: runneradmin"
                 Write-Host "Password: Use your RDP_PASSWORD secret."
                 Write-Host "The runner will remain active for debugging. Manually cancel the job when done."
                 Write-Host "----------------------------------------------------------------------"
                 Start-Sleep -Seconds 21600
                 exit 1
            }
            Pause-For-RdpDebug "Could not locate vcvars64.bat. Cannot proceed with build."
        }

    # --- MODIFIED: Use PowerShell wrapper for try/catch ---
    - name: Run Build Script
      env:
        BUILD_BASE_ENV: ${{ github.workspace }}\build
        PREFIX_ENV: C:\ServBay\packages\apache
        # VCVARSALL is set in the environment by the previous step
      shell: powershell # Change shell to powershell
      run: |
        # Define the pause function again or ensure it's available
        function Pause-For-RdpDebug($errorMessage) {
            Write-Error "ERROR ENCOUNTERED: $errorMessage"
            Write-Host "----------------------------------------------------------------------"
            Write-Host "WORKFLOW PAUSED FOR DEBUGGING (Max ~6 hours)"
            Write-Host "Connect via RDP to investigate."
            Write-Host "RDP URL: ${{ steps.setup-rdp.outputs.rdp_url }}"
            Write-Host "Username: runneradmin"
            Write-Host "Password: Use your RDP_PASSWORD secret."
            Write-Host "The runner will remain active for debugging. Manually cancel the job when done."
            Write-Host "----------------------------------------------------------------------"
            Start-Sleep -Seconds 21600 # Pause for 6 hours
            exit 1
        }

        Write-Host "VCVARSALL is set to: $env:VCVARSALL"
        if (-not $env:VCVARSALL) {
             Pause-For-RdpDebug "VCVARSALL environment variable is not set before calling build script."
        }

        Write-Host "Starting build_all.bat..."
        try {
            # Execute the batch script using cmd /c
            # Ensure VCVARSALL is used by the cmd environment if needed within the bat script itself
            # (Often build scripts call vcvars internally, but good practice)
            cmd /c "call `"$env:VCVARSALL`" > nul && call build_all.bat"
            # Check the exit code of the last command run by cmd
            if ($LASTEXITCODE -ne 0) {
                throw "build_all.bat failed with exit code $LASTEXITCODE"
            }
            Write-Host "build_all.bat completed successfully."
        } catch {
            # Call the pause function on error
            Pause-For-RdpDebug "Build script execution failed: $($_.Exception.Message)"
        }

    - name: Upload Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: apache-windows-build
        path: C:\ServBay\packages\apache
        if-no-files-found: error # Keep this, if build fails and pauses, this won't run anyway